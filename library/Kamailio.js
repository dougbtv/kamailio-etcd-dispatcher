module.exports = function(log,opts) {

	var moment = require('moment');
	var fs = require('fs');

	/*

	// boxen example
	
	var thing = {
		box1: {
			ip: 192.168.1.100,
			weight: 15,
			port: 5060
			heartbeat: {uuid}
		},
		box2: {
			ip: 192.168.1.101,
			heartbeat: {uuid}
		}
	}

	*/

	this.createList = function(boxen,callback) {

		// log.it("boxes_for_createlist",{boxen: boxen});

		validateBoxen(boxen,function(boxes){

			// log.it("valid_boxes_createlist",{boxes: boxes});
			
			setWeights(boxes,function(weightedboxes){

				// log.it("weighted_boxes_result",{boxes: weightedboxes});

				writeKamailioDispatcherList(boxes,function(err){

					callback(null);

				});

			});
			
		});

	}

	var writeKamailioDispatcherList = function(boxen,callback) {

		// Ok, now we have the boxen all calculated...
		// Let's just rip through the list and write out each box.

		// ---------- example kamailio dispatcher.list -------
		// 1 sip:192.168.100.202:5060 0 0 weight=50
		// ---------------------------------------------------

		var resultlist = "# Autogenerated @ " + moment().format("dddd, MMMM Do YYYY, h:mm:ss a") + "\n";

		for (var boxkey in boxen){
			if (boxen.hasOwnProperty(boxkey)) {
				var box = boxen[boxkey];
				var port = "5060";
				if (box.port) {
					port = box.port;
				}
				var line = "1 " + "sip:" + box.ip + ":" + port + " 0 0 weight=" + box.calculated_weight;
				resultlist = resultlist + line + "\n";
			}
		}

		log.it("writing_dispatcher_list",{ flatfile: resultlist, lines: resultlist.split("\n") });

		fs.writeFile(opts.listpath, resultlist, function(err) {
						
			if(err) {
				log.error("file_write_error",{err: err});
			}

			callback(err);
			
		}); 


	}

	var validateBoxen = function(boxen,callback) {

		// Let's collect just valid boxes.
		var valid = {};

		// Ok, let's cycle all the boxes.
		for (var boxkey in boxen){
			if (boxen.hasOwnProperty(boxkey)) {
				var box = boxen[boxkey];
				// console.log("!trace each boxen: ",box);
				if (box.complete) {

					// That seems good!
					valid[boxkey] = box;

				} else {
					// Invalid box.
					log.warn("kama_box_notready",{ box: boxkey, boxfull: box });
				}
			}
		}

		callback(valid);

	}

	var setWeights = function(boxes,callback) {

		// So, now we have all the valid boxes.
		// We need to figure out the weights.
		// That being said:
		//  - count the number of boxes.
		//  - see which have weights.
		//  - set the weights for the specific boxes.
		//  - spread the rest out between the unspecified
		//  - figure out what to do with the remainder.
		
		var number_boxes = 0;
		var weights = {};
		var number_weighted = 0;
		var total_weight = 0;

		for (var boxkey in boxes){
			if (boxes.hasOwnProperty(boxkey)) {

				var box = boxes[boxkey];

				// Count number of boxes.
				number_boxes++;

				// Mark each box that has a weight.
				if (box.weight) {
					number_weighted++;
					weights[boxkey] = parseInt(box.weight);
					total_weight = total_weight + weights[boxkey];
				}

			}
		}

		switch (number_boxes) {
			case 0:
				log.warn("empty_cluster",{msg: "No hosts in the cluster"});
				break;
			case 1:
				log.warn("cluster_of_one",{msg: "Only one host in the cluster."});
				break;
		}

		// console.log("!trace number boxes: ",number_boxes);
		// console.log("!trace weights: ",weights);

		// How many are unweighted?
		var number_unweighted = number_boxes - number_weighted;

		// How much percent do we split?
		var split_percent = 100 - total_weight;

		// Ok, this is the remainder we'll add to the first box.
		var add_to_first = 0;

		// What's the split for each unweighted box?
		var each_split;



		// We split that between unweighted boxes.
		var no_unweighted = false;
		if (!number_unweighted) {
			// That's a divide by zero problem.
			// All boxes must be weighted in this case.
			// We have to give the remainder to the first box.
			no_unweighted = true;
			add_to_first = (100 - total_weight);

			if (number_boxes) {
				log.warn("no_unweighted",{ number_weighted: number_weighted});
			}

		} else {

			// Ok, we can split that percent among all the boxes.
			// Let's floor each split.
			each_split = Math.floor(split_percent / number_unweighted);

			// Now we can figure out our remainder.
			var sum_unweight = (number_unweighted * each_split);
			var sum_all_weights = (sum_unweight + total_weight);

			add_to_first = 100 - sum_all_weights;

			// Let's log the remainder.
			/*
				log.it("distribution_calculated",{
					number_weighted: number_weighted,
					number_unweighted: number_unweighted,
					each_split: each_split,
					remainder: add_to_first,
					sum_unweight: sum_unweight,
					sum_all_weights: sum_all_weights,
				});
			*/


		}

		// Now we apply 
		for (var boxkey in boxes){
			if (boxes.hasOwnProperty(boxkey)) {
				var box = boxes[boxkey];

				// Assign the appropriate weight.
				// if specific weight...
				if (box.weight) {
					boxes[boxkey].calculated_weight = weights[boxkey];
				} else {
					// Distributed weight.
					boxes[boxkey].calculated_weight = each_split;
				}

				// Add any remainder weight to the first unweighted box.
				if ((add_to_first && !box.weight) || (add_to_first && no_unweighted)) {
					boxes[boxkey].calculated_weight = boxes[boxkey].calculated_weight + add_to_first;
					add_to_first = false;
				}
			}
		}

		callback(boxes);

	}

}